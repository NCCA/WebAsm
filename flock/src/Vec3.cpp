#include "Vec3.h"
#include <cmath>
#include <cassert>

//----------------------------------------------------------------------------------------------------------------------
/// @brief define EPSILON for floating point comparison
//----------------------------------------------------------------------------------------------------------------------
#ifndef EPSILON
  const static float  EPSILON = 0.001f;
#endif
//----------------------------------------------------------------------------------------------------------------------
/// @brief FCompare macro used for floating point comparision functions
//----------------------------------------------------------------------------------------------------------------------
  #define FCompare(a,b) \
      ( ((a)-EPSILON)<(b) && ((a)+EPSILON)>(b) )

//----------------------------------------------------------------------------------------------------------------------
void Vec3::set(float _x,   float _y,  float _z )
{
	m_x=_x;
	m_y=_y;
	m_z=_z;
}

//----------------------------------------------------------------------------------------------------------------------
void Vec3::set( const Vec3& _v )
{
   m_x=_v.m_x;
   m_y=_v.m_y;
   m_z=_v.m_z;
}

//----------------------------------------------------------------------------------------------------------------------
void Vec3::set( const Vec3* _v )
{
	m_x=_v->m_x;
	m_y=_v->m_y;
	m_z=_v->m_z;
}
//----------------------------------------------------------------------------------------------------------------------
float Vec3::dot( const Vec3& _v  )const
{
	return m_x * _v.m_x + m_y * _v.m_y + m_z * _v.m_z;
}
//----------------------------------------------------------------------------------------------------------------------
void Vec3::null()
{
	m_x=0.0f;
	m_y=0.0f;
	m_z=0.0f;
}

//----------------------------------------------------------------------------------------------------------------------
float& Vec3::operator[](const int& _i )
{
	assert(_i >=0 || _i<=3);
	return (&m_x)[_i];
}



//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::operator-() const
{
	return Vec3(-m_x,-m_y,-m_z);
}


//----------------------------------------------------------------------------------------------------------------------
void Vec3::operator+=(const Vec3& _v   )
{
	m_x+=_v.m_x;
	m_y+=_v.m_y;
	m_z+=_v.m_z;
}

//----------------------------------------------------------------------------------------------------------------------
void Vec3::operator/=(float _v  )
{
	assert(_v !=0);
	m_x/=_v;
	m_y/=_v;
	m_z/=_v;
}
//----------------------------------------------------------------------------------------------------------------------
void Vec3::operator*=(	float _v  )
{
	m_x*=_v;
	m_y*=_v;
	m_z*=_v;
}
//----------------------------------------------------------------------------------------------------------------------
void Vec3::operator-=(const Vec3& _v )
{
	m_x-=_v.m_x;
	m_y-=_v.m_y;
	m_z-=_v.m_z;
}

//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::operator/(float _v  )const
{
	return Vec3(
								m_x/_v,
								m_y/_v,
								m_z/_v
								);
}

//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::operator+( const Vec3& _v )const
{
	return Vec3(
								m_x+_v.m_x,
								m_y+_v.m_y,
								m_z+_v.m_z
								);
}

//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::operator-(
                         const Vec3& _v
                        )const
{
	return Vec3(
								m_x-_v.m_x,
								m_y-_v.m_y,
								m_z-_v.m_z
							 );
}

//----------------------------------------------------------------------------------------------------------------------
bool Vec3::operator==(const Vec3& _v )const
{
	return (
					FCompare(_v.m_x,m_x)  &&
					FCompare(_v.m_y,m_y)  &&
					FCompare(_v.m_z,m_z)
				 );
}
//----------------------------------------------------------------------------------------------------------------------
bool Vec3::operator!=(const Vec3& _v  )const
{
	return (
					!FCompare(_v.m_x,m_x) ||
					!FCompare(_v.m_y,m_y) ||
					!FCompare(_v.m_z,m_z)
				 );
}
//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::operator*( const Vec3& _v  )const
{
	return Vec3(
								m_x*_v.m_x,
								m_y*_v.m_y,
								m_z*_v.m_z
							 );
}

//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::operator/( const Vec3& _v )const
{
	return Vec3(
								m_x/_v.m_x,
								m_y/_v.m_y,
								m_z/_v.m_z
								);
}

//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::operator *(	 float _i  )const
{
	return Vec3(
								m_x*_i,
								m_y*_i,
								m_z*_i
							 );
}



//----------------------------------------------------------------------------------------------------------------------
Vec3 & Vec3::operator=( const Vec3& _v	)
{
	m_x = _v.m_x;
	m_y = _v.m_y;
	m_z = _v.m_z;
	return *this;
}

//----------------------------------------------------------------------------------------------------------------------
Vec3 & Vec3::operator=(float _v   )
{
  m_x = _v;
  m_y = _v;
  m_z = _v;
  return *this;
}
//----------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------
void Vec3::cross( const Vec3& _v1, const Vec3& _v2  )
{
  m_x=_v1.m_y*_v2.m_z-_v1.m_z*_v2.m_y;
  m_y=_v1.m_z*_v2.m_x-_v1.m_x*_v2.m_z;
  m_z=_v1.m_x*_v2.m_y-_v1.m_y*_v2.m_x;
}

//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::cross( const Vec3& _v )const
{
  return Vec3(
              m_y*_v.m_z - m_z*_v.m_y,
              m_z*_v.m_x - m_x*_v.m_z,
              m_x*_v.m_y - m_y*_v.m_x
             );

}


//----------------------------------------------------------------------------------------------------------------------
void Vec3::normalize()
{
  float len=(float)sqrt(m_x*m_x+m_y*m_y+m_z*m_z);
  assert(len!=0);
  m_x/=len;
  m_y/=len;
  m_z/=len;
}

//----------------------------------------------------------------------------------------------------------------------
float Vec3::inner( const Vec3& _v  )const
{
  return (
          (m_x * _v.m_x) +
          (m_y * _v.m_y) +
          (m_z * _v.m_z)
         );
}

//----------------------------------------------------------------------------------------------------------------------
Vec3 Vec3::outer(const Vec3 &_v  )  const
{
  float x = (m_y * _v.m_z) - (m_z * _v.m_y);
  float y = (m_z * _v.m_x) - (m_x * _v.m_z);
  float z = (m_x * _v.m_y) - (m_y * _v.m_x);

  return Vec3(x,y,z);
}

//----------------------------------------------------------------------------------------------------------------------
float Vec3::length() const
{
  return (float)sqrt((m_x*m_x)+(m_y*m_y)+(m_z*m_z));
}


//----------------------------------------------------------------------------------------------------------------------
float Vec3::lengthSquared() const
{
  return m_x * m_x+m_y * m_y+ m_z*m_z;
}

Vec3 Vec3::reflect(const Vec3 & _n) const
 {
   float d=this->dot(_n);
   //  I - 2.0 * dot(N, I) * N
   return Vec3(
                m_x-2.0*d*_n.m_x,
                m_y-2.0*d*_n.m_y,
                m_z-2.0*d*_n.m_z
              );
 }

std::ostream& operator<<( std::ostream& _output, const Vec3& _v	)
{
  return _output<<"["<<_v.m_x<<","<<_v.m_y<<","<<_v.m_z<<"]";
}
void Vec3::clamp(float _min, float _max )
{
  m_x<_min ? m_x = _min : m_x;
  m_x>_max ? m_x = _max : m_x;

  m_y<_min ? m_y = _min : m_y;
  m_y>_max ? m_y = _max : m_y;

  m_z<_min ? m_z = _min : m_z;
  m_z>_max ? m_z = _max : m_z;


}
void Vec3::clamp(float _max )
{
  m_x<-_max ? m_x = -_max : m_x;
  m_x>_max ? m_x = _max : m_x;

  m_y<-_max ? m_y = -_max : m_y;
  m_y>_max ? m_y = _max : m_y;

  m_z<-_max ? m_z = -_max : m_z;
  m_z>_max ? m_z = _max : m_z;


}

